# Import necessary OpenROAD libraries
from openroad import Tech, Design, Timing
from pathlib import Path
import pdn, odb, drt, openroad as ord # Import OpenROAD specific libraries

# --- File Paths and Design Setup ---

# Set paths to library and design files - Replace with your actual paths
# Assuming library files are in lib/ and lef/ subdirectories relative to libDir and lefDir
# Example paths, adjust according to your project structure
libDir = Path("../libraries/lib")
lefDir = Path("../libraries/lef")
techlefDir = Path("../libraries/lef")
designDir = Path("../Design")

# Design specific settings
design_name = "1_synth" # Name of your design verilog file (without extension)
design_top_module_name = "gcd" # Top module name in your verilog
clock_port_name = "clk" # Name of the clock port in the top module

# Initialize OpenROAD technology and design objects
tech = Tech()

# Read all liberty (.lib) and LEF files from the library directories
libFiles = libDir.glob("*.lib")
techLefFiles = techlefDir.glob("*.tech.lef")
lefFiles = lefDir.glob('*.lef')

# Load liberty timing libraries
for libFile in libFiles:
    print(f"Reading liberty: {libFile}")
    tech.readLiberty(libFile.as_posix())
# Load technology and cell LEF files
for techLefFile in techLefFiles:
    print(f"Reading tech LEF: {techLefFile}")
    tech.readLef(techLefFile.as_posix())
for lefFile in lefFiles:
    print(f"Reading cell LEF: {lefFile}")
    tech.readLef(lefFile.as_posix())

# Create design and read Verilog netlist
design = Design(tech)
verilogFile = designDir/str(design_name + ".v")
print(f"Reading Verilog: {verilogFile}")
design.readVerilog(verilogFile.as_posix())

# Link the design to resolve hierarchy and connect modules
print(f"Linking design: {design_top_module_name}")
design.link(design_top_module_name)

# --- Clock Definition ---

# Define a clock signal with a 40 ns period on the 'clk' port
clock_period = 40.0 # ns
clock_name = "core_clock"
print(f"Creating clock {clock_name} on port {clock_port_name} with period {clock_period} ns")
design.evalTclString(f"create_clock -period {clock_period} [get_ports {clock_port_name}] -name {clock_name}")

# Propagate the defined clock signal
print("Propagating clock")
design.evalTclString(f"set_propagated_clock [get_clocks {{{clock_name}}}]")

# --- Floorplanning ---

# Initialize floorplan parameters
floorplan = design.getFloorplan()
# Find the site definition from the technology LEF
# You can find site names in your tech LEF or by inspecting tech.getDB().getTech().getSites()
site_name = "FreePDK45_38x28_10R_NP_162NW_34O" # Example site name, REPLACE with your site name
site = floorplan.findSite(site_name)
if not site:
    print(f"Error: Site '{site_name}' not found in technology LEF. Please check site name or LEF files.")
    # Exit or handle error appropriately if site is critical
    exit()

utilization = 0.45 # Target core utilization (45%)
aspect_ratio = 1.0 # Aspect ratio of the core area (Height/Width)
margin_micron = 12.0 # Margin between core and die area in microns

# Convert margin to DBU (Database Units)
margin_dbu = design.micronToDBU(margin_micron)

# Initialize floorplan with utilization, aspect ratio, margin, and site
# This method calculates die and core areas based on utilization, aspect ratio, and margin
print(f"Initializing floorplan with utilization={utilization}, aspect_ratio={aspect_ratio}, margin={margin_micron} um")
floorplan.initFloorplan(utilization, aspect_ratio, margin_dbu, margin_dbu, margin_dbu, margin_dbu, site)

# Create placement tracks based on the technology and floorplan
print("Making placement tracks")
floorplan.makeTracks()

# Dump DEF after floorplanning
design.evalTclString(f"write_def {design_name}.floorplan.def")
print(f"Saved {design_name}.floorplan.def")

# --- I/O Pin Placement ---

# Configure and run I/O pin placement
print("Placing I/O pins")
io_placer = design.getIOPlacer()
# Find metal layers by name
metal8 = design.getTech().getDB().getTech().findLayer("metal8")
metal9 = design.getTech().getDB().getTech().findLayer("metal9")

if not all([metal8, metal9]):
    print("Error: Metal 8 or Metal 9 layer not found for I/O placement. Please check your LEF files.")
    # Exit or handle error appropriately
else:
    # Set layers for horizontal and vertical pin placement
    io_placer.addHorLayer(metal8) # Place horizontal pins on Metal 8
    io_placer.addVerLayer(metal9) # Place vertical pins on Metal 9

    # Run I/O placement using simulated annealing (random mode)
    io_placer.runAnnealing(True)
    print("I/O pins placed.")

# Dump DEF after I/O placement
design.evalTclString(f"write_def {design_name}.io_placed.def")
print(f"Saved {design_name}.io_placed.def")

# --- Macro Placement (if macros exist) ---

# Identify macro instances in the design (masters of type 'BLOCK')
macros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]
print(f"Found {len(macros)} macros in the design.")

if len(macros) > 0:
    print("Placing macros")
    macro_placer = design.getMacroPlacer()

    # Macro placement parameters
    # Fence region coordinates in microns
    fence_lx_micron = 32.0
    fence_ly_micron = 32.0
    fence_ux_micron = 55.0
    fence_uy_micron = 60.0

    # Halo around macros in microns
    halo_micron = 5.0

    # Note: The OpenROAD MacroPlacer API `place` function does not have a direct parameter
    # for minimum distance *between* macros. The halo setting provides clearance around them.
    # To enforce strict minimum distance, you might need post-placement legalization or manual adjustments.

    # Run macro placement using the specified parameters
    macro_placer.place(
        # Basic parameters (adjust as needed)
        num_threads = 64, # Number of threads for placement
        max_num_macro = len(macros), # Process all identified macros
        min_num_macro = 0,
        max_num_inst = 0, # Do not include standard cells in this placement step
        min_num_inst = 0,
        tolerance = 0.1,
        max_num_level = 2,
        coarsening_ratio = 10.0,
        large_net_threshold = 50,
        signature_net_threshold = 50,

        # Set halo around each macro instance
        halo_width = halo_micron,
        halo_height = halo_micron,

        # Set fence region for macro placement (macros are encouraged/required to be inside this box)
        fence_lx = fence_lx_micron,
        fence_ly = fence_ly_micron,
        fence_ux = fence_ux_micron,
        fence_uy = fence_uy_micron,

        # Weights (adjust for different optimization goals)
        area_weight = 0.1,
        outline_weight = 100.0,
        wirelength_weight = 100.0,
        guidance_weight = 10.0,
        fence_weight = 10.0, # Weight to keep macros inside the fence
        boundary_weight = 50.0,
        notch_weight = 10.0,
        macro_blockage_weight = 10.0,
        pin_access_th = 0.0,

        # Other parameters (adjust as needed)
        target_util = utilization, # Target utilization for the core area
        target_dead_space = 0.05,
        min_ar = 0.33,
        snap_layer = 4, # Snap macros to a specific layer's grid (optional, adjust layer index)
        bus_planning_flag = False,
        report_directory = "" # Directory to save reports
    )
    print("Macro placement finished.")

    # Dump DEF after macro placement
    design.evalTclString(f"write_def {design_name}.macro_placed.def")
    print(f"Saved {design_name}.macro_placed.def")
else:
    print("No macros found. Skipping macro placement.")


# --- Global Placement ---

# Configure and run global placement for standard cells
print("Running global placement")
global_placer = design.getReplace()

# Set placement modes
global_placer.setTimingDrivenMode(False) # Disable timing-driven mode for simplicity
global_placer.setRoutabilityDrivenMode(True) # Enable routability-driven mode
global_placer.setUniformTargetDensityMode(True) # Use uniform target density

# The request specified 30 iterations for global routing, not placement.
# The number of iterations for placement is often controlled internally by the solver.
# We'll run the standard global placement steps.
global_placer.setInitialPlaceMaxIter(10) # Example: Limit initial placement iterations
global_placer.setInitDensityPenalityFactor(0.05) # Example: Set initial density penalty

# Execute initial and detailed global placement steps
global_placer.doInitialPlace(threads = 4) # Perform initial placement
global_placer.doNesterovPlace(threads = 4) # Perform Nesterov-based global placement

# Reset the placer state
global_placer.reset()
print("Global placement finished.")

# Dump DEF after global placement
design.evalTclString(f"write_def {design_name}.global_placed.def")
print(f"Saved {design_name}.global_placed.def")

# --- Initial Detailed Placement (allowing specified displacement) ---

print("Running initial detailed placement")
detailed_placer = design.getOpendp()

# Max allowed displacement in microns for X and Y
max_disp_x_micron = 0.5
max_disp_y_micron = 0.5

# Convert max displacement to DBU (Database Units)
max_disp_x_dbu = design.micronToDBU(max_disp_x_micron)
max_disp_y_dbu = design.micronToDBU(max_disp_y_micron)

# Remove existing filler cells before detailed placement (if any)
detailed_placer.removeFillers()

# Run detailed placement
# Parameters: max_disp_x_dbu, max_disp_y_dbu, debug_filename, legalization_only
# Setting legalization_only to False allows for movement beyond simple legalization if needed.
detailed_placer.detailedPlacement(max_disp_x_dbu, max_disp_y_dbu, "", False)
print("Initial detailed placement finished.")

# Dump DEF after initial detailed placement
design.evalTclString(f"write_def {design_name}.dp_initial.def")
print(f"Saved {design_name}.dp_initial.def")

# --- Power Delivery Network (PDN) Construction ---

print("Building Power Delivery Network (PDN)")
pdngen = design.getPdnGen()

# Set up global power/ground connections
# This connects standard cell power pins to global VDD/VSS nets
for net in design.getBlock().getNets():
    if net.getSigType() == "POWER" or net.getSigType() == "GROUND":
        net.setSpecial() # Mark power/ground nets as special nets

# Find or create VDD/VSS nets - assuming VDD and VSS are the required nets
VDD_net = design.getBlock().findNet("VDD")
VSS_net = design.getBlock().findNet("VSS")

if VDD_net == None:
    VDD_net = odb.dbNet_create(design.getBlock(), "VDD")
    VDD_net.setSpecial()
    VDD_net.setSigType("POWER")
    print("Created VDD net.")
if VSS_net == None:
    VSS_net = odb.dbNet_create(design.getBlock(), "VSS")
    VSS_net.setSpecial()
    VSS_net.setSigType("GROUND")
    print("Created VSS net.")

# Connect standard cell power/ground pins to the global VDD/VSS nets
# Adjust pin patterns based on your standard cell library's VDD/VSS pin names
design.getBlock().addGlobalConnect(region = None,
    instPattern = ".*",
    pinPattern = "VCC|VDD",
    net = VDD_net,
    do_connect = True)
design.getBlock().addGlobalConnect(region = None,
    instPattern = ".*",
    pinPattern = "VSS|GND",
    net = VSS_net,
    do_connect = True)

# Apply the global connections
design.getBlock().globalConnect()
print("Applied global power/ground connections.")

# Set core power domain using the identified VDD/VSS nets
pdngen.setCoreDomain(power = VDD_net, switched_power = None, ground = VSS_net, secondary = [])
print("Set core power domain.")

# Get relevant metal layers by name
m1 = design.getTech().getDB().getTech().findLayer("metal1")
m4 = design.getTech().getDB().getTech().findLayer("metal4")
m5 = design.getTech().getDB().getTech().findLayer("metal5")
m6 = design.getTech().getDB().getTech().findLayer("metal6")
m7 = design.getTech().getDB().getTech().findLayer("metal7")
m8 = design.getTech().getDB().getTech().findLayer("metal8")

# Ensure required layers exist
if not all([m1, m4, m5, m6, m7, m8]):
    print("Error: One or more required metal layers (M1, M4, M5, M6, M7, M8) not found. Please check your LEF files.")
    # Exit or handle error appropriately
    exit()

# Define PDN parameters in microns as requested
# Standard Cell Grid Parameters
stdcell_ring_width_micron = 5.0
stdcell_ring_spacing_micron = 5.0
stdcell_m1_followpin_width_micron = 0.07
stdcell_m4_strap_width_micron = 1.2
stdcell_m4_strap_spacing_micron = 1.2
stdcell_m4_strap_pitch_micron = 6.0
stdcell_m7_strap_width_micron = 1.4
stdcell_m7_strap_spacing_micron = 1.4
stdcell_m7_strap_pitch_micron = 10.8
stdcell_m8_strap_width_micron = 1.4
stdcell_m8_strap_spacing_micron = 1.4
stdcell_m8_strap_pitch_micron = 10.8

# Macro Grid Parameters (if applicable)
macro_strap_width_micron = 1.2
macro_strap_spacing_micron = 1.2
macro_strap_pitch_micron = 6.0

# Via cut pitch (0 um as requested)
via_cut_pitch_micron = 0.0

# Offset (0 um as requested for all cases)
offset_micron = 0.0

# Convert all parameters to DBU (Database Units)
stdcell_ring_width_dbu = design.micronToDBU(stdcell_ring_width_micron)
stdcell_ring_spacing_dbu = design.micronToDBU(stdcell_ring_spacing_micron)
stdcell_m1_followpin_width_dbu = design.micronToDBU(stdcell_m1_followpin_width_micron)
stdcell_m4_strap_width_dbu = design.micronToDBU(stdcell_m4_strap_width_micron)
stdcell_m4_strap_spacing_dbu = design.micronToDBU(stdcell_m4_strap_spacing_micron)
stdcell_m4_strap_pitch_dbu = design.micronToDBU(stdcell_m4_strap_pitch_micron)
stdcell_m7_strap_width_dbu = design.micronToDBU(stdcell_m7_strap_width_micron)
stdcell_m7_strap_spacing_dbu = design.micronToDBU(stdcell_m7_strap_spacing_micron)
stdcell_m7_strap_pitch_dbu = design.micronToDBU(stdcell_m7_strap_pitch_micron)
stdcell_m8_strap_width_dbu = design.micronToDBU(stdcell_m8_strap_width_micron)
stdcell_m8_strap_spacing_dbu = design.micronToDBU(stdcell_m8_strap_spacing_micron)
stdcell_m8_strap_pitch_dbu = design.micronToDBU(stdcell_m8_strap_pitch_micron)

macro_strap_width_dbu = design.micronToDBU(macro_strap_width_micron)
macro_strap_spacing_dbu = design.micronToDBU(macro_strap_spacing_micron)
macro_strap_pitch_dbu = design.micronToDBU(macro_strap_pitch_micron)

via_cut_pitch_dbu = design.micronToDBU(via_cut_pitch_micron)
offset_dbu = design.micronToDBU(offset_micron)

# Create the core grid for standard cells
domains = [pdngen.findDomain("Core")]
# Define a halo around macros where the standard cell grid will be excluded
# Use the same halo size as defined for macro placement
stdcell_grid_macro_halo_dbu = [design.micronToDBU(halo_micron)] * 4

for domain in domains:
    # Make the main core grid structure for standard cells
    pdngen.makeCoreGrid(domain = domain,
        name = "stdcell_grid",
        starts_with = pdn.GROUND, # Choose starting net (POWER or GROUND)
        pin_layers = [],
        generate_obstructions = [],
        powercell = None,
        powercontrol = None,
        powercontrolnetwork = "STAR")

# Get the created core grid object
stdcell_grid = pdngen.findGrid("stdcell_grid")[0] # findGrid returns a list

# Add rings to the standard cell grid on M7 and M8
print(f"Adding standard cell rings (M7, M8) with width {stdcell_ring_width_micron} um, spacing {stdcell_ring_spacing_micron} um")
pdngen.makeRing(grid = stdcell_grid,
    layer0 = m7, width0 = stdcell_ring_width_dbu, spacing0 = stdcell_ring_spacing_dbu,
    layer1 = m8, width1 = stdcell_ring_width_dbu, spacing1 = stdcell_ring_spacing_dbu,
    starts_with = pdn.GRID, # Start with grid connection type
    offset = [offset_dbu] * 4, # Apply 0 um offset to all sides
    pad_offset = [offset_dbu] * 4, # Apply 0 um pad offset
    extend = pdn.BOUNDARY, # Extend rings to the core boundary
    nets = [], # Use nets from the grid definition
    allow_out_of_die = False) # Rings should typically be within the die boundary

# Add followpin straps on M1 for standard cell rail connection
print(f"Adding standard cell followpin straps (M1) with width {stdcell_m1_followpin_width_micron} um")
pdngen.makeFollowpin(grid = stdcell_grid,
    layer = m1,
    width = stdcell_m1_followpin_width_dbu,
    extend = pdn.CORE) # Extend throughout the core area following standard cell power pins

# Add horizontal/vertical straps to the standard cell grid on M4, M7, M8
print(f"Adding standard cell straps (M4, M7, M8)")
# M4 straps
pdngen.makeStrap(grid = stdcell_grid,
    layer = m4,
    width = stdcell_m4_strap_width_dbu,
    spacing = stdcell_m4_strap_spacing_dbu,
    pitch = stdcell_m4_strap_pitch_dbu,
    offset = offset_dbu, # 0 um offset
    number_of_straps = 0, # Auto-calculate number based on pitch and area
    snap = False, # Do not snap strap start to grid lines (can be True if desired)
    starts_with = pdn.GRID, # Start with grid connection type
    extend = pdn.CORE, # Extend throughout the core area
    nets = []) # Use nets from the grid definition

# M7 straps
pdngen.makeStrap(grid = stdcell_grid,
    layer = m7,
    width = stdcell_m7_strap_width_dbu,
    spacing = stdcell_m7_strap_spacing_dbu,
    pitch = stdcell_m7_strap_pitch_dbu,
    offset = offset_dbu, # 0 um offset
    number_of_straps = 0, # Auto-calculate number
    snap = False, # Do not snap strap start
    starts_with = pdn.GRID, # Start with grid connection type
    extend = pdn.RINGS, # Extend to the power rings
    nets = []) # Use nets from the grid definition

# M8 straps
pdngen.makeStrap(grid = stdcell_grid,
    layer = m8,
    width = stdcell_m8_strap_width_dbu,
    spacing = stdcell_m8_strap_spacing_dbu,
    pitch = stdcell_m8_strap_pitch_dbu,
    offset = offset_dbu, # 0 um offset
    number_of_straps = 0, # Auto-calculate number
    snap = False, # Do not snap strap start
    starts_with = pdn.GRID, # Start with grid connection type
    extend = pdn.BOUNDARY, # Extend to the boundary (or RINGS)
    nets = []) # Use nets from the grid definition


# Create via connections between layers for the standard cell grid
print(f"Adding standard cell via connections (M1-M4, M4-M7, M7-M8) with cut pitch {via_cut_pitch_micron} um")
# Connect M1 to M4
pdngen.makeConnect(grid = stdcell_grid,
    layer0 = m1, layer1 = m4,
    cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
    vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")

# Connect M4 to M7
pdngen.makeConnect(grid = stdcell_grid,
    layer0 = m4, layer1 = m7,
    cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
    vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")

# Connect M7 to M8
pdngen.makeConnect(grid = stdcell_grid,
    layer0 = m7, layer1 = m8,
    cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
    vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")


# Create power grid for macro blocks (if macros exist)
if len(macros) > 0:
    print("Building PDN for macros")
    # Use the halo calculated for macro placement for PDN exclusion around macros
    macro_pdn_halo_dbu = [design.micronToDBU(halo_micron)] * 4

    for i, macro_inst in enumerate(macros):
        # Create a separate instance grid for each macro
        for domain in domains: # Assuming macros are in the core domain
            pdngen.makeInstanceGrid(domain = domain,
                name = f"macro_grid_{i}", # Unique name for each macro grid
                starts_with = pdn.GROUND, # Choose starting net (POWER or GROUND) for the macro grid
                inst = macro_inst,
                halo = macro_pdn_halo_dbu, # Halo around the macro instance
                pg_pins_to_boundary = True, # Connect macro PG pins to boundary of the instance grid
                default_grid = False, # This is not the default core grid
                generate_obstructions = [], # Layers to generate routing obstructions on
                is_bump = False)

        # Get the created macro grid object
        macro_grid = pdngen.findGrid(f"macro_grid_{i}")[0] # findGrid returns a list

        # Add straps to the macro grid on M5 and M6
        print(f"Adding macro straps (M5, M6) for {macro_inst.getName()} with width {macro_strap_width_micron} um, spacing {macro_strap_spacing_micron} um, pitch {macro_strap_pitch_micron} um")
        # M5 straps for macros
        pdngen.makeStrap(grid = macro_grid,
            layer = m5,
            width = macro_strap_width_dbu,
            spacing = macro_strap_spacing_dbu,
            pitch = macro_strap_pitch_dbu,
            offset = offset_dbu, # 0 um offset
            number_of_straps = 0, # Auto-calculate number
            snap = True, # Snap strap start to grid lines
            starts_with = pdn.GRID, # Start with grid connection type
            extend = pdn.CORE, # Extend within the macro instance area (or use pdn.BOUNDARY/RINGS if applicable)
            nets = []) # Use nets from the grid definition

        # M6 straps for macros
        pdngen.makeStrap(grid = macro_grid,
            layer = m6,
            width = macro_strap_width_dbu,
            spacing = macro_strap_spacing_dbu,
            pitch = macro_strap_pitch_dbu,
            offset = offset_dbu, # 0 um offset
            number_of_straps = 0, # Auto-calculate number
            snap = True, # Snap strap start
            starts_with = pdn.GRID, # Start with grid connection type
            extend = pdn.CORE, # Extend within the macro instance area
            nets = []) # Use nets from the grid definition

        # Create via connections for the macro grid and connections to core grid layers
        print(f"Adding macro via connections (M4-M5, M5-M6, M6-M7) with cut pitch {via_cut_pitch_micron} um")
        # Connect M4 (from stdcell grid, potentially extending under macro halo) to M5 (macro grid)
        pdngen.makeConnect(grid = macro_grid,
            layer0 = m4, layer1 = m5,
            cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
            vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")
        # Connect M5 to M6 (within macro grid)
        pdngen.makeConnect(grid = macro_grid,
            layer0 = m5, layer1 = m6,
            cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
            vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")
        # Connect M6 (macro grid) to M7 (from stdcell grid, potentially extending over macro halo)
        pdngen.makeConnect(grid = macro_grid,
            layer0 = m6, layer1 = m7,
            cut_pitch_x = via_cut_pitch_dbu, cut_pitch_y = via_cut_pitch_dbu,
            vias = [], techvias = [], max_rows = 0, max_columns = 0, ongrid = [], split_cuts = dict(), dont_use_vias = "")
else:
    print("No macros found. Skipping macro PDN construction.")


# Verify and build the final power delivery network
print("Verifying and building PDN geometry")
pdngen.checkSetup() # Verify the PDN configuration
pdngen.buildGrids(False) # Build the grids and geometry (False means not multi-cpu)
pdngen.writeToDb(True) # Write the generated PDN shapes to the design database
pdngen.resetShapes() # Clear temporary shapes
print("PDN construction finished.")

# Dump DEF after PDN construction
design.evalTclString(f"write_def {design_name}.pdn.def")
print(f"Saved {design_name}.pdn.def")

# --- Clock Tree Synthesis (CTS) ---

print("Running Clock Tree Synthesis (CTS)")
# Ensure clock is propagated before CTS
design.evalTclString(f"set_propagated_clock [get_clocks {{{clock_name}}}]")

# Set unit resistance and capacitance values for wires
rc_resistance = 0.03574 # Unit resistance
rc_capacitance = 0.07516 # Unit capacitance
print(f"Setting wire RC for clock and signal nets (R={rc_resistance}, C={rc_capacitance})")
design.evalTclString(f"set_wire_rc -clock -resistance {rc_resistance} -capacitance {rc_capacitance}")
design.evalTclString(f"set_wire_rc -signal -resistance {rc_resistance} -capacitance {rc_capacitance}")

# Get the TritonCTS module
cts = design.getTritonCts()

# Configure clock buffers to be used for CTS
buffer_cell = "BUF_X2" # Name of the buffer cell in your library
print(f"Setting CTS buffer to {buffer_cell}")
cts.setBufferList(buffer_cell)
cts.setRootBuffer(buffer_cell) # Use this buffer at the clock root
cts.setSinkBuffer(buffer_cell) # Use this buffer for clock sinks

# Run CTS
cts.runTritonCts()
print("CTS finished.")

# Dump DEF after CTS
design.evalTclString(f"write_def {design_name}.cts.def")
print(f"Saved {design_name}.cts.def")


# --- Final Detailed Placement (Legalization after CTS) ---
# Running detailed placement again after CTS helps legalize cells that may have moved
# due to buffer insertion or optimization.

print("Running final detailed placement after CTS")
# Detailed placement parameters (using the same max displacement as initial DP)
# Using DBU values calculated earlier: max_disp_x_dbu, max_disp_y_dbu

# Run detailed placement. This step primarily legalizes placement and might
# make small adjustments.
detailed_placer.detailedPlacement(max_disp_x_dbu, max_disp_y_dbu, "", False)
print("Final detailed placement finished.")

# Dump DEF after final detailed placement
design.evalTclString(f"write_def {design_name}.dp_final.def")
print(f"Saved {design_name}.dp_final.def")

# --- Filler Cell Insertion ---

print("Inserting filler cells")
db = ord.get_db() # Get the OpenROAD database object
filler_masters = list()
filler_cells_prefix = "FILLCELL_" # Common prefix for generated filler instances

# Find filler cell masters in the libraries with type "CORE_SPACER"
for lib in db.getLibs():
    for master in lib.getMasters():
        if master.getType() == "CORE_SPACER":
            filler_masters.append(master)

if len(filler_masters) == 0:
    print("Warning: No filler cells found in libraries with type CORE_SPACER. Skipping filler insertion.")
else:
    # Run filler placement to fill gaps in rows
    # Note: fillerPlacement requires detail placement engine (getOpendp())
    num_non_fillers_before = detailed_placer.numNonFillerInsts()
    detailed_placer.fillerPlacement(
        filler_masters = filler_masters, # List of filler cell master objects
        prefix = filler_cells_prefix, # Prefix for created filler instance names
        verbose = False # Suppress verbose output
    )
    num_non_fillers_after = detailed_placer.numNonFillerInsts()
    num_fillers_inserted = len(design.getBlock().getInsts()) - len(macros) - num_non_fillers_after
    print(f"Inserted {num_fillers_inserted} filler cells.")

# Dump DEF after filler insertion
design.evalTclString(f"write_def {design_name}.fillers.def")
print(f"Saved {design_name}.fillers.def")

# --- Global Routing ---

print("Running Global Routing")
global_router = design.getGlobalRouter()

# Set routing layer ranges for signal and clock nets (M1 to M7 as per implied usage)
# Find layer levels from layer objects
m1_level = m1.getRoutingLevel()
m7_level = m7.getRoutingLevel()

# Set min/max routing layers for signal nets
global_router.setMinRoutingLayer(m1_level)
global_router.setMaxRoutingLayer(m7_level)

# Set min/max routing layers for clock nets (often same as signal layers, or higher layers)
# Using the same range (M1-M7) as per requirement context regarding standard cell grids
global_router.setMinLayerForClock(m1_level)
global_router.setMaxLayerForClock(m7_level)

# Adjust congestion parameters (example values)
global_router.setAdjustment(0.5) # Congestion adjustment factor (0.0 to 1.0)
global_router.setVerbose(True) # Enable verbose output

# The request specified 30 iterations for global routing. The globalRoute API call
# does not have a simple iteration count parameter exposed. Iterations are managed
# internally by the router based on convergence and other parameters.
# Running global route (False for non-timing driven, True for timing driven - assuming non-timing)
global_router.globalRoute(False)
print("Global routing finished.")

# Dump DEF after global routing
design.evalTclString(f"write_def {design_name}.global_routed.def")
print(f"Saved {design_name}.global_routed.def")


# --- Detailed Routing ---

print("Running Detailed Routing")
detailed_router = design.getTritonRoute()

# Configure detailed routing parameters (using example parameters and layer range)
params = drt.ParamStruct()
params.outputMazeFile = ""
params.outputDrcFile = f"{design_name}.drc" # Output DRC violations to a file
params.outputCmapFile = ""
params.outputGuideCoverageFile = ""
params.dbProcessNode = "" # Process node name (optional)
params.enableViaGen = True # Enable via generation during routing
params.drouteEndIter = 1 # Number of detailed routing iterations (1 is typical for initial run)
params.viaInPinBottomLayer = "" # Optional: specific layers for via-in-pin
params.viaInPinTopLayer = ""   # Optional: specific layers for via-in-pin
params.orSeed = -1 # Random seed (-1 for time-based)
params.orK = 0
# Set routing layer range for detailed routing
params.bottomRoutingLayer = "metal1"
params.topRoutingLayer = "metal7"
params.verbose = 1 # Verbosity level (0: quiet, 1: normal, 2: debug)
params.cleanPatches = True # Clean up routing patches after completion
params.doPa = True # Perform post-route antenna fixing (PA)
params.singleStepDR = False # Run detailed routing in a single step
params.minAccessPoints = 1 # Minimum access points for pin connections
params.saveGuideUpdates = False # Save routing guide updates (for debugging)

# Set the configured parameters for the detailed router
detailed_router.setParams(params)

# Run detailed routing
detailed_router.main()
print("Detailed routing finished.")

# Dump DEF after detailed routing
design.evalTclString(f"write_def {design_name}.detailed_routed.def")
print(f"Saved {design_name}.detailed_routed.def")


# --- Save Final Design ---

# Write the final design to an ODB database file
final_odb_file = f"{design_name}.final.odb"
print(f"Saving final design to {final_odb_file}")
design.writeDb(final_odb_file)
print("OpenROAD flow complete.")
